#' Fit a stan model using (modified) code and data generated by brms
#'
#' @param file Load/save csvs to this filepath and name.
#' @param seed Random seed passed to `rstan::stan()`.
#' @param bform A `brms` formula. N.B., transformations of variables within the formula may not be picked up by
#' post-processing functions; it's generally better to create new, transformed variables.
#' @param bdata A data frame used to fit the model.
#' @param bpriors Priors specified by `brms` functions.
#' @param car1 Logical. Generate CAR(1) errors?
#' @param sample_prior Passed on to `brms::brm()`.
#' @param knots Passed on to `brms::brm()`.
#' @param d_x A vector representing the spacing in time of observations in each series,
#' equal to zero at the first timestep. If `NULL` (the default), `d_x` is drawn from the dataframe `bdata`.
#' @param ... Passed on to `rstan::stan()`.
#' @param family A `brmsfamily` object. Note that some post-processing functions assume a student-t likelihood.
#' @param backend Run Stan's algorithms using `rstan` or `cmdstanr`.
#' @param overwrite Overwrite an exising model stored as CSVs? Defaults to `FALSE`.
#'
#' @return A `brms` model object fitted with `rstan`.
#' @importFrom stringr str_remove str_extract str_detect
#' @importFrom brms brm rename_pars make_stancode make_standata student is.brmsfit
#' @importFrom rstan stan read_stan_csv
#' @importFrom dplyr %>%
#' @export
#'
#' @examples
#' library("brms")
#' seed <- 1
#' data <- read.csv(paste0(system.file("extdata", package = "bgamcar1"), "/data.csv"))
#' fit <- fit_stan_model(
#'   paste0(system.file("extdata", package = "bgamcar1"), "/test"),
#'   seed,
#'   bf(y | cens(ycens, y2 = y2) ~ 1),
#'   data,
#'   prior(normal(0, 1), class = Intercept),
#'   car1 = FALSE,
#'   save_warmup = FALSE,
#'   chains = 3
#' )
fit_stan_model <- function(file,
                           seed,
                           bform,
                           bdata,
                           bpriors = NULL,
                           car1 = TRUE,
                           sample_prior = "no",
                           knots = NULL,
                           d_x = NULL,
                           family = student(),
                           backend = "rstan",
                           overwrite = FALSE,
                           ...) {

  model_saved <- get_model(file)

  # generate stan data:

  data <- brms::make_standata(
    bform,
    data = bdata,
    prior = bpriors,
    family = family,
    sample_prior = sample_prior,
    knots = knots
  )

  # check for presence of d_x in data or supplied as an argument:

  if (car1) {
    if (is.null(d_x)) {
      if (is.null(bdata$d_x)) {
        stop("Column d_x not found in data.")
      } else {
        data$s <- bdata$d_x
      }
    } else {
      data$s <- d_x
    }
  }

  # generate stan code:

  code <- brms::make_stancode(
    bform,
    data = bdata,
    prior = bpriors,
    family = family,
    sample_prior = sample_prior,
    knots = knots
  )

  if (car1) {
    code <- modify_stancode(code)
  }

  # fit model:

  stanmod <- if (length(model_saved$csvs) > 0 && !overwrite) {
    rstan::read_stan_csv(model_saved$csvs)
  } else if (backend == "rstan") {
    rstan::stan(
      model_code = code,
      data = data,
      sample_file = file, # output in csv format
      seed = seed,
      ...
    )
  } else if (backend == "cmdstanr") {
    if (!requireNamespace("cmdstanr", quietly = TRUE)) {
      stop(
        "Package \"cmdstanr\" must be installed for backend == \"cmdstanr\".",
        .call = FALSE
      )
    }
    fit_cmdstan_model(
      code, data, seed, model_saved$path, model_saved$basename, file, ...
    )
  } else stop("Backend must be either \"rstan\" or \"cmdstanr\".")

  # feed back into brms:

  if (length(model_saved$rds) > 0 && !overwrite) {
    brmsmod <- brm(
      bform,
      data = bdata,
      prior = bpriors,
      family = family,
      knots = knots,
      file = file,
      file_refit = "never"
    )
  } else {
    brmsmod <- brm(
      bform,
      data = bdata,
      prior = bpriors,
      family = family,
      knots = knots,
      empty = TRUE
    )
    # save empty fit:
    brms:::write_brmsfit(brmsmod, file = file)
  }

  # add stan model to fit slot:
  brmsmod$fit <- stanmod
  brmsmod <- rename_pars(brmsmod)

  return(brmsmod)
}

get_model <- function(file) {
  path <- str_remove(file, "\\/[^\\/]+$")# remove base filename
  bname <- str_extract(file, "[^\\/]+$") # extract base filename
  # list csv and rds files matching file path/basename combo:
  csvfiles <- list.files(path = path,
                         pattern = paste0("^", paste0(bname, "[-_]\\d\\.csv")),
                         full.names = TRUE)
  rdsfiles <- list.files(path = path,
                         pattern = paste0("^", paste0(bname, "\\.rds")),
                         full.names = TRUE)
  list(csvs = csvfiles, path = path, basename = bname, rds = rdsfiles)
}

fit_cmdstan_model <- function(code, data, seed, path, basename, file, ...) {
  model_setup <- cmdstanr::cmdstan_model(stan_file = cmdstanr::write_stan_file(code))
  model <- model_setup$sample(data = data, seed = seed, ...)
  model$save_output_files(
    dir = path,
    basename = basename,
    random = FALSE,
    timestamp = FALSE
  )
  rstan::read_stan_csv(model$output_files())
}

# unexported functions from the brms package that are reproduced here:
#
# write_brmsfit <- function (x, file, compress = TRUE) {
#   stopifnot(is.brmsfit(x))
#   file <- check_brmsfit_file(file)
#   x$file <- file
#   saveRDS(x, file = file, compress = compress)
#   invisible(x)
# }
#
# check_brmsfit_file <- function (file) {
#   file <- as_one_character(file)
#   file_ending <- tolower(get_matches("\\.[^\\.]+$", file))
#   if (!isTRUE(file_ending == ".rds")) {
#     file <- paste0(file, ".rds")
#   }
#   file
# }
#
# as_one_character <- function (x, allow_na = FALSE) {
#   s <- substitute(x)
#   x <- as.character(x)
#   if (length(x) != 1L || anyNA(x) && !allow_na) {
#     s <- deparse0(s, max_char = 100L)
#     stop2("Cannot coerce '", s, "' to a single character value.")
#   }
#   x
# }
#
# get_matches <- function (pattern, text, simplify = TRUE, first = FALSE, ...) {
#   x <- regmatches(text, gregexpr(pattern, text, ...))
#   if (first) {
#     x <- lapply(x, function(t) if (length(t))
#       t[1]
#       else t)
#   }
#   if (simplify) {
#     if (first) {
#       x <- lapply(x, function(t) if (length(t))
#         t
#         else "")
#     }
#     x <- unlist(x)
#   }
#   x
# }
#
# deparse0 <- function (x, max_char = NULL, ...) {
#   out <- collapse(deparse(x, ...))
#   if (isTRUE(max_char > 0)) {
#     out <- substr(out, 1L, max_char)
#   }
#   out
# }
#
# stop2 <- function(...) {
#   stop(..., call. = FALSE)
# }
#
# collapse <- function(..., sep = "") {
#   paste(..., sep = sep, collapse = "")
# }
